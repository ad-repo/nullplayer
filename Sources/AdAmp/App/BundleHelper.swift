import Foundation

/// Helper to access bundled resources in both SPM development and standalone app bundle
///
/// IMPORTANT: Bundle.module (auto-generated by SPM) crashes with fatalError when it can't find
/// the resource bundle at expected paths. This happens in release builds installed outside the
/// build directory. We must check Bundle.main FIRST and only use Bundle.module in DEBUG builds.
enum BundleHelper {
    
    // MARK: - App Version
    
    /// Cached Info.plist dictionary (loaded once from source file for debug builds)
    private static let sourceInfoPlist: [String: Any]? = {
        #if DEBUG
        // In debug builds, Bundle.main.infoDictionary is empty because we run as a bare executable.
        // Load Info.plist from the source Resources directory via Bundle.module.
        if let url = Bundle.module.url(forResource: "Info", withExtension: "plist"),
           let data = try? Data(contentsOf: url),
           let plist = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: Any] {
            return plist
        }
        #endif
        return nil
    }()
    
    /// The app's marketing version (e.g., "1.0") from Info.plist CFBundleShortVersionString
    static var appVersion: String {
        // Try main bundle first (works in app bundle)
        if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String {
            return version
        }
        // Fall back to source Info.plist (debug builds)
        if let version = sourceInfoPlist?["CFBundleShortVersionString"] as? String {
            return version
        }
        return "1.0"
    }
    
    /// The app's build number (e.g., "1") from Info.plist CFBundleVersion
    static var buildNumber: String {
        // Try main bundle first (works in app bundle)
        if let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
            return build
        }
        // Fall back to source Info.plist (debug builds)
        if let build = sourceInfoPlist?["CFBundleVersion"] as? String {
            return build
        }
        return "1"
    }
    
    /// Full version string combining version and build (e.g., "1.0.1")
    static var fullVersion: String {
        "\(appVersion).\(buildNumber)"
    }
    
    // MARK: - Resources
    
    /// Cached SPM resource bundle for release builds running from build directory
    private static let spmResourceBundle: Bundle? = {
        // When running release build directly from .build directory, resources are in
        // AdAmp_AdAmp.bundle next to the executable
        let executableURL = Bundle.main.executableURL ?? URL(fileURLWithPath: CommandLine.arguments[0])
        let buildDir = executableURL.deletingLastPathComponent()
        let spmBundleURL = buildDir.appendingPathComponent("AdAmp_AdAmp.bundle")
        if FileManager.default.fileExists(atPath: spmBundleURL.path) {
            return Bundle(url: spmBundleURL)
        }
        return nil
    }()
    
    /// Returns the bundle containing app resources
    /// - In SPM development: Uses Bundle.module
    /// - In standalone app: Uses Bundle.main's Resources folder
    /// - In release from build dir: Uses AdAmp_AdAmp.bundle
    static var resourceBundle: Bundle {
        #if DEBUG
        // In debug builds, try module bundle first (SPM development)
        return Bundle.module
        #else
        // In release builds, try SPM bundle first (running from build dir), then main bundle
        return spmResourceBundle ?? Bundle.main
        #endif
    }
    
    /// Find a resource URL, checking main bundle first then module bundle (DEBUG only)
    ///
    /// The order is important: Bundle.module crashes in release builds when installed
    /// outside the build directory, so we must try Bundle.main first.
    static func url(forResource name: String, withExtension ext: String?, subdirectory: String? = nil) -> URL? {
        // Try main bundle first (works in standalone app)
        if let url = Bundle.main.url(forResource: name, withExtension: ext, subdirectory: subdirectory) {
            return url
        }
        
        // Try main bundle Resources subdirectory (common app bundle structure)
        if let subdirectory = subdirectory {
            if let url = Bundle.main.url(forResource: name, withExtension: ext, subdirectory: "Resources/\(subdirectory)") {
                return url
            }
        }
        
        // Try without subdirectory in main bundle
        if let url = Bundle.main.url(forResource: name, withExtension: ext) {
            return url
        }
        
        // Try main bundle Resources folder directly
        if let resourceURL = Bundle.main.resourceURL {
            var searchURL = resourceURL.appendingPathComponent(name)
            if let ext = ext {
                searchURL = searchURL.appendingPathExtension(ext)
            }
            if FileManager.default.fileExists(atPath: searchURL.path) {
                return searchURL
            }
            
            // Also try with subdirectory
            if let subdirectory = subdirectory {
                var subSearchURL = resourceURL.appendingPathComponent(subdirectory).appendingPathComponent(name)
                if let ext = ext {
                    subSearchURL = subSearchURL.appendingPathExtension(ext)
                }
                if FileManager.default.fileExists(atPath: subSearchURL.path) {
                    return subSearchURL
                }
            }
        }
        
        #if DEBUG
        // Only try Bundle.module in DEBUG builds - it crashes in release builds
        // when the app is installed outside the SPM build directory
        if let url = Bundle.module.url(forResource: name, withExtension: ext, subdirectory: subdirectory) {
            return url
        }
        #else
        // In release builds running from SPM build directory, check the AdAmp_AdAmp.bundle
        if let spmBundle = spmResourceBundle {
            // Try Resources subdirectory first (SPM puts resources there)
            if let url = spmBundle.url(forResource: name, withExtension: ext, subdirectory: "Resources") {
                return url
            }
            if let subdirectory = subdirectory {
                if let url = spmBundle.url(forResource: name, withExtension: ext, subdirectory: "Resources/\(subdirectory)") {
                    return url
                }
            }
            if let url = spmBundle.url(forResource: name, withExtension: ext, subdirectory: subdirectory) {
                return url
            }
            if let url = spmBundle.url(forResource: name, withExtension: ext) {
                return url
            }
        }
        #endif
        
        return nil
    }
    
    /// Find a resource URL in a specific subdirectory
    static func url(forResource name: String, withExtension ext: String?, inDirectory directory: String) -> URL? {
        return url(forResource: name, withExtension: ext, subdirectory: directory)
    }
    
    /// Get the path to the Presets directory
    static var presetsDirectory: URL? {
        // Try main bundle first (standalone app)
        if let url = Bundle.main.url(forResource: "Presets", withExtension: nil) {
            return url
        }
        if let resourceURL = Bundle.main.resourceURL {
            let presetsURL = resourceURL.appendingPathComponent("Presets")
            if FileManager.default.fileExists(atPath: presetsURL.path) {
                return presetsURL
            }
            // Also try Resources/Presets
            let resourcePresetsURL = resourceURL.appendingPathComponent("Resources").appendingPathComponent("Presets")
            if FileManager.default.fileExists(atPath: resourcePresetsURL.path) {
                return resourcePresetsURL
            }
        }
        
        #if DEBUG
        // Only try Bundle.module in DEBUG builds
        if let url = Bundle.module.url(forResource: "Presets", withExtension: nil, subdirectory: "Resources") {
            return url
        }
        if let url = Bundle.module.url(forResource: "Presets", withExtension: nil) {
            return url
        }
        #else
        // In release builds running from SPM build directory
        if let spmBundle = spmResourceBundle {
            if let url = spmBundle.url(forResource: "Presets", withExtension: nil, subdirectory: "Resources") {
                return url
            }
            if let url = spmBundle.url(forResource: "Presets", withExtension: nil) {
                return url
            }
        }
        #endif
        
        return nil
    }
    
    /// Get the path to the Textures directory
    static var texturesDirectory: URL? {
        // Try main bundle first (standalone app)
        if let url = Bundle.main.url(forResource: "Textures", withExtension: nil) {
            return url
        }
        if let resourceURL = Bundle.main.resourceURL {
            let texturesURL = resourceURL.appendingPathComponent("Textures")
            if FileManager.default.fileExists(atPath: texturesURL.path) {
                return texturesURL
            }
            // Also try Resources/Textures
            let resourceTexturesURL = resourceURL.appendingPathComponent("Resources").appendingPathComponent("Textures")
            if FileManager.default.fileExists(atPath: resourceTexturesURL.path) {
                return resourceTexturesURL
            }
        }
        
        #if DEBUG
        // Only try Bundle.module in DEBUG builds
        if let url = Bundle.module.url(forResource: "Textures", withExtension: nil, subdirectory: "Resources") {
            return url
        }
        if let url = Bundle.module.url(forResource: "Textures", withExtension: nil) {
            return url
        }
        #else
        // In release builds running from SPM build directory
        if let spmBundle = spmResourceBundle {
            if let url = spmBundle.url(forResource: "Textures", withExtension: nil, subdirectory: "Resources") {
                return url
            }
            if let url = spmBundle.url(forResource: "Textures", withExtension: nil) {
                return url
            }
        }
        #endif
        
        return nil
    }
    
    /// Get the path to a skin file (wsz)
    static func skinURL(named name: String) -> URL? {
        return url(forResource: name, withExtension: "wsz")
    }
}
